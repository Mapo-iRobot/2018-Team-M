# Mission 1
## 경로
|   기호   |           설명           |   점수   |
| :------: | :----------------------- | :------: |
|    M05   | 코어 샘플 추출           |    16    |
|          | 가스 코어 샘플 베이스로  |    10    |
|    M06   | 튜브 모듈 삽입           |    16    |
| **총합** |                          |  **42**  |

## 기술적 구현 (하드웨어)
### 코어 샘플 추출 및 귀환 모듈
제작자 : 전준혁  


### 튜브 모듈 삽입 부분
제작자 : 안효준  
* 회전 시에 튜브 모듈이 빠져 직각빔(2x4) 2개와 십자페그를 이용하여 잠금 부분을 제작하였다. 특히 삽입 시에는 쉽게 빠져야 하므로 모서리가 둥근 직각빔을 선택하였다.
* 프레임과 판떼기를 이용하여 튜브 모듈을 잘 잡도록 설계하였다.

## 기술적 구현 (소프트웨어)


## 코드
```c
#pragma config(Sensor,    S1,        rb,        sensorEV3_Color)
#pragma config(Sensor,    S2,        lb,        sensorEV3_Color)
#pragma config(Sensor,    S3,        rf,        sensorEV3_Color)
#pragma config(Sensor,    S4,        lf,        sensorEV3_Color)
#pragma config(Motor,    motorA,    rw,    tmotorEV3_Large,    PIDControl,    encoder)
#pragma config(Motor,    motorB,    lm,    tmotorEV3_Large,    PIDControl,    encoder)
#pragma config(Motor,    motorC,    rm,    tmotorEV3_Large,    PIDControl,    encoder)
#pragma config(Motor,    motorD,    lw,    tmotorEV3_Large,    PIDControl,    encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float rfav=0, lfav=0, rbav=0, lbav=0;


//Init Functions
void initAll();
void initEncoder();
void initMotor();

void go(int left, int right);

//Convert Centimeter Distance to Rotation Angle
int cm(float distance);

//Convert Direction of Encoder
int motorEncoder(int index);

//Calculate Average of White
void calcWhite(int iD);

//Ignore One Black Line
void ignoreLine(int sensor1 = lb, int sensor2 = rb);

void initAll()
{
	initMotor();
	initEncoder();
}

void initEncoder()
{
	nMotorEncoder[lw]=0;
	nMotorEncoder[rm]=0;
	nMotorEncoder[lm]=0;
	nMotorEncoder[rw]=0;
}

void initMotor() {
	motor[lw] = 0;
	motor[rw] = 0;
	motor[lm] = 0;
	motor[rm] = 0;
}

int motorEncoder(int index) {
	return nMotorEncoder[index];
}

void calcWhite(int iD)
{
	int rbsum=0, lbsum=0, rfsum=0, lfsum=0, count = 0;

	initAll();
	while (motorEncoder(lw) < cm(iD)) {
		count++;
		rfsum=rfsum+SensorValue(rf);
		lfsum=lfsum+SensorValue(lf);
		rbsum=rbsum+SensorValue(rb);
		lbsum=lbsum+SensorValue(lb);
		go(40,40);
		delay(3);
	}
	go(0, 0);

	rfav=(rfsum/count)*0.95;
	lfav=(lfsum/count)*0.95;
	rbav=(rbsum/count)*0.95;
	lbav=(lbsum/count)*0.95;
	displayBigTextLine(0, "       L     ");
	displayBigTextLine(2, "    %02d   %02d  ", lbav, lfav);
	displayBigTextLine(4, "    %02d   %02d  ", rbav, rfav);
	displayBigTextLine(6, "       R     ");
	displayBigStringAt(25, 103, "B");
	displayBigStringAt(140, 103, "F");
	displayTextLine(8, "-------------------------------");
}

void go(int left,int right)
{
	motor[lw] = left;
	motor[rw] = right;
}

int cm(float distance)
{
	return (int)(20.46277839811427 * distance);
}

float deg(float degree) {
	return 1.8571428571 * degree;
}

void untilWhiteLine(int sensor1 = lb, int sensor2 = rb) {
	while(true)
	{
		go(30,30);
		//If White Detected, Break Loop
		if(SensorValue(sensor1) > lfav || SensorValue(sensor2) > rfav)
		{
			break;
		}
	}
	go(0, 0);
}

void ignoreLine(int sensor1, int sensor2) {
	untilWhiteLine(sensor1, sensor2);
	go(30,30);
	delay(500);
	go(0, 0);
}

task main()
{
	initAll();
	while (-motorEncoder(lm) < 270) {
		displayBigTextLine(9, "%d", -motorEncoder(lm));
		motor[lm] = -40;
	}
	motor[lm] = 0;
	
	initAll();
	calcWhite(5);

	//Go Ahead for 27.5cm
	while (motorEncoder(motorA) < cm(22.5)) {
		go(40,40);
	}

	//Turn 90 counter-clockwise
	initEncoder();
	while (motorEncoder(lw) < deg(90)) {
		//displayBigTextLine(9, "%d", motorEncoder(lw));
		go(20, -20);
	}

	//Align with Walls
	go(30, 30);
	delay(1250);

	//Stop for Start
	go(0, 0);
	delay(750);

	//Motor is Reversed -> See Directions
	setMotorReversed(lw, true);
	setMotorReversed(rw, true);

	//Go 62cm until the extraction site
	initEncoder();
	while(-motorEncoder(lw) < cm(63)) {
		go(20, 20);
		displayBigTextLine(9, "%dcm", -motorEncoder(lw) / 20.46277839811427);
	}
	go(0, 0);
		
	//Put down the Chamber
	initEncoder();
	while (motorEncoder(lm) < 270) {
		motor[lm] = 20;
	}
	motor[lm] = 0;

	//Extracting the Cores
	initEncoder();
	while (-motorEncoder(lw) < cm(12.5)) {
		go(20, 20);
	}
	go(0, 0);

	
	
	//Line Tracing - 
	initAll();
	
	go(5, 20);
	delay(500);
	
	while (SensorValue(rf) < rfav) {
		if (SensorValue(lf) > lfav) {
			go(20, 5);
		}
		else {
			go(-5, 20);
		}
	}
	go(0, 0);

	initAll();
	while (motorEncoder(lw) < cm(10)) {
		go(20, 20);
	}
	go(0, 0);
	delay(1000);

	//Way Back Home
	//Go Back
	initAll();
	while (-motorEncoder(lw) < cm(15)) {
		go(-20, -20);
	}
	go(0, 0);
	delay(1000);

	//Turn 180
	initEncoder();
	while (-motorEncoder(lw) < deg(180)) {
		go(20, -20);
	}
	
	//Go to Base
	go(50, 50);
	delay(3000);
	
}
```
