#pragma config(Sensor, S1,     bls,            sensorEV3_Color)
#pragma config(Sensor, S2,     rs,             sensorEV3_Color)
#pragma config(Sensor, S3,     ls,             sensorEV3_Color)
#pragma config(Sensor, S4,     brs,            sensorEV3_Color)
#pragma config(Motor,  motorA,          lm,            tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          rt,            tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          lt,            tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          rm,            tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int rsum=0,lsum=0,blsum=0,brsum=0,ll=0,rl=0,bll=0,brl=0;
//declare variable
void reset()
{
	nMotorEncoder[lm]=0;
	nMotorEncoder[rm]=0;
	nMotorEncoder[rt]=0;
	nMotorEncoder[lt]=0;
}
void go(int a,int b)
{
	motor[lm]=-a;
	motor[rm]=-b;
}
void go_en(int a, int b, int c)
{
	reset();
	if(a>0||b>0)
		while(nMotorEncoder[rm]>=-c)
			go(a,b);
	else
		while(nMotorEncoder[rm]<=c)
			go(a,b);
	go(0,0);
}
void halt()
{
	go(0,0);
	delay(400);
}
void get()
{
	reset();
	go(30,30);
	for(int i=1 ; i<=5 ; i++)
	{
		rsum+=SensorValue[rs];
		lsum+=SensorValue[ls];
		delay(3);
	}
	ll=(lsum/5)*0.95;
	rl=(rsum/5)*0.95;
	displayBigTextLine(1,"%d",ll);
	displayBigTextLine(3,"%d",rl);
	go_en(50,50,330);
	go(50,50);
	for(int i=1; i<=5; i++)
	{
		blsum+=SensorValue[bls];
		brsum+=SensorValue[brs];
		delay(3);
	}
	bll=(blsum/5)*0.95;
	brl=(brsum/5)*0.95;
	displayBigTextLine(5,"%d",bll);
	displayBigTextLine(7,"%d",brl);
}
int rvalue()
{
	int rsum=0,rval=0,rmax=0,rmin=100,rsen;
	for(int i=1 ; i<=5 ; i++)
	{
		rsen=SensorValue[rs];
		rsum+=rsen;
		if(rsen>rmax)
			rmax=rsen;
		if(rsen<rmin)
			rmin=rsen;
		delay(1);
	}
	rsum-=rmin;
	rsum-=rmax;
	rval=rsum/3;
	return rval;
}
int lvalue()
{
	int lsum=0,lval=0,lmax=0,lmin=100,lsen;
	for(int i=1 ; i<=5 ; i++)
	{
		lsen=SensorValue[ls];
		lsum+=lsen;
		if(lsen>lmax)
			lmax=lsen;
		if(lsen<lmin)
			lmin=lsen;
		delay(1);
	}
	lsum-=lmin;
	lsum-=lmax;
	lval=lsum/3;
	return lval;
}
int blvalue()
{
	int blsum=0,blval=0,blmax=0,blmin=100,blsen;
	for(int i=1 ; i<=5 ; i++)
	{
		blsen=SensorValue(bls);
		blsum+=blsen;
		if(blsen>blmax)
			blmax=blsen;
		if(blsen<blmin)
			blmin=blsen;
		delay(1);
	}
	blsum-=blmin;
	blsum-=blmax;
	blval=blsum/3;
	return blval;
}
int brvalue()
{
	int brsum=0,brval=0,brmax=0,brmin=100,brsen;
	for(int i=1 ; i<=5 ; i++)
	{
		brsen=SensorValue(brs);
		brsum+=brsen;
		if(brsen>brmax)
			brmax=brsen;
		if(brsen<brmin)
			brmin=brsen;
		delay(1);
	}
	brsum-=brmin;
	brsum-=brmax;
	brval=brsum/3;
	return brval;
}
void adjust()
{
	go(30,30);
	while(true)
	{
		if(lvalue()>=ll)
		{
			while(rvalue()<rl)
			{
				go(-3,10);
			}
			return;
		}
		if(rvalue()>=rl)
		{
			while(lvalue()<ll)
			{
				go(10,-3);
			}
			return;
		}
	}
}
void smooth_go(int a,int b,int k)
{
	for(int i=5 ; i>=1 ; i--)
	{
		go((a/5)*i,(b/5)*i);
		for (int j=1;j<=k;j++)
			delay(1);
	}
}
void pid()
{
	float fv,bv,error,lsv,bsv,kp=10;
	reset();
	while(1)
	{
		lsv=SensorValue[ls];
		bsv=SensorValue[bls];
		fv=(lsv/ll);
		bv=(bsv/bll);
		error=fv-bv;
		go(20+ kp*error,20- kp*error);
		displayBigTextLine(9,"%.2f %.2f",fv,bv);
		displayBigTextLine(11,"%.2f",error);
		if(rvalue()>=rl&&nMotorEncoder[lm]<=-750)
			break;
	}
}
task main()
{
	get();
	go_en(51,50,1450);
	adjust();
	go_en(31,30,300);
	adjust();
	halt();
	go_en(-30,-30,100);
	halt();
	go_en(20,30,600);
	go_en(30,30,120);
	go_en(0,30,475);
	adjust();
	go_en(30,30,210);
	while(nMotorEncoder[rt]>=-200)
		motor[rt]=-100;
	motor[rt]=0;
	go_en(-10,-10,20);
	while(lvalue()<=ll)
		go(-10,40);
	go_en(-10,40,50);
	pid();
	go_en(30,30,270);
	while(nMotorEncoder[lt]<=2000)
		motor[lt]=100;


}
